\chapter{Boolean Circuits}

Continuing on from last time, Boolean Circuits use AND/OR/NOT as basic operations and can be represented as DAG's. Let's formally define them.

\begin{definition}
    Boolean Circuits

    A $(n, m, s)$-Boolean Circuit is a DAG with $n + s$ vertices. $n$ refers to the number of input variables, $m$ is the number of output variables, and $s$ is the size of the circuit.
    \begin{itemize}
        \item Exactly n of these vertices are labeled as inputs $x[0], x[1], ..., x[n-1]$
        \item The other s vertices are AND/OR/NOT gates
        \begin{itemize}
            \item Each AND and OR gate has exactly two incoming edges
            \item Each NOT gate has one incoming edges
        \end{itemize}
        \item m of the gates are labeled as outputs $y[0], y[1], ..., y[m - 1]$
    \end{itemize}
    \begin{center}
        \img{./img/boolcirc-example.png}
    \end{center}
\end{definition}

We know that DAG's can be topologicallys sorted (i.e. there is a layering of the vertices such that for every edge (i, j), h(i) < h(j)), so Boolean Circuits can be topologically sorted too. This is important for computation of circuit outputs. How can we compute the outputs?
\begin{itemize}
    \item layer the DAG via topological sort so that all input vertices are in layer 0
    \item we have computed in layers 0, 1, ..., k - 1
    \item now for each vertex in layer k, assign it the value of its operation on its wires (i.e. AND gate should be w1 $\land$ w2)
    \item output $y \in \{0,1\}^m$ s.t. $y = y[0] \circ y[1] \circ ... \circ y[m-1]$
\end{itemize}

\subsection*{Choosing Basic Operations}
We stated in our definition of a boolean circuit that the basic operations it uses are AND/OR/NOT. Why did we pick these operations in particular? Could we have picked some other operations?

\begin{definition}
    NAND 
    \[
        \text{NAND: } \{0,1\}^2 \rightarrow \{0,1\}  
    \]
    \[
        \text{NAND}(a, b) = \lnot(a \land b)
    \]
\end{definition}

NAND Circuits are defined similarly to Boolean Circuits, the only difference being the basic operations available. In NAND Circuits, only NAND is used. Is there a meaningful difference between the two? Is one more powerful than the other?

We can show that NAND circuits can be easily simulated using Boolean gates.
\begin{itemize}
    \item simply convert NAND gates to and AND followed by a NOT
    \item NAND $\rightarrow$ AND + NOT
\end{itemize}

Is the opposite true? Can we express Boolean Circuits only in terms of NAND gates?
\begin{itemize}
    \item NOT(a) = NAND(a, a)
    \item AND(a, b) = NOT(NAND(a, b)) = NAND(NAND(a, b), NAND(a, b))
    \item OR(a, b) = NAND(NOT(a), NOT(b)) = NAND(NAND(a, a), NAND(b, b))
\end{itemize}
So yes, we can simulate a Boolean Circuit with a NAND circuit.

\begin{theorem}
    Boolean circuits are \kw{equivalent} to NAND circuits in computational power. 
\end{theorem}

\begin{definition}
    Equivalent 

    f is computable by a Boolean Circuit $\iff$ f is computable by a NAND circuit.
\end{definition}

\hr

\theoremproof{
    
Every function $f: \{0,1\}^n \rightarrow \{0,1\}^m$ can be computed by a Boolean circuit of size $O(n * m * 2^n)$.
}
{
(for m = 1)

Given $f: \{0,1\}^n \rightarrow \{0,1\}^m$, an arbitrary function mapping boolean strings to binary, define the set 
\[
    S = \{\alpha: f(\alpha) = 1\}
\]

For each binary string $\alpha \in {0, 1}^n$, define 
\[
    E_\alpha: \{0, 1\}^n \rightarrow \{0,1\}    
\]
\begin{equation}
    E_\alpha = 
    \begin{cases}
        1 & \text{if } x = \alpha \\
        0 & else
    \end{cases}
\end{equation}

\begin{example}
    So if $\alpha = (1, 1, ..., 1)$, we can construct a circuit using a chain of AND gates in order to compute $E_\alpha$. The same is true if $\alpha = (1, 1, ..., 1, 0)$, except that we must add in a NOT gate after the final AND gate. If we extend this logic to the entire domain of $\{0,1\}^n$, it is clear that we can construct a circuit for arbitrary values of $\alpha$ in the domain. 
\end{example}

We can use $E_\alpha$ to compute arbitary f. 

Consider the set S from before, which is simply the set of binary strings in which f is 1. We have shown that it is possible to create a circuit for arbitary $E_\alpha$ (which is equal to 1 if the input x = $\alpha$), so it is easy to create a circuit that computes f. It is simply
\[
    f(x) = \text{OR}(E_{\alpha_0}(x), E_{\alpha_1}(x), ..., E_{\alpha_{n-1}}(x)))
\]

which follows from the logic that if x is equal to any one of the binary strings that cause f(x) to be 1, then the circuit should output 1. By chaining together all the circuits we constructed before with OR gates, we can construct the final circuit for arbitary f.
}

How many gates will we use? 
\[
    \text{\# gates used } \le |S|(2n - 1) + (|S| - 1)
\]
\[
    = O(n * 2^n)  
\]

We can extend this logic beyond the $m = 1$ by using the above to compute each bit of $y$.

\kw{Remark}: We can do better with a circuit of size $O(\frac{2^n}{n})$, but this goes beyond the scope of this class.

\hr

Some functions, such as addition and multiplication, are frequently used. As a result, engineers work to make far more efficient circuits for them than guaranteed above. Addition can be computed in an $O(n)$ circuit while multiplication can be computed in an $O(n^2)$ circuit. However, some functions require an exponential number of gates to compute. We will show this.

\vspace{.5cm}

\kw{Big Idea} We can encode circuits as binary strings. 

Two corollaries to this idea: 
\begin{enumerate}
    \item Some functions need exponential size circuits
    \item Universal circuits exist (i.e. general computers)
\end{enumerate}

\theoremproof{
    Every (n, m, s) NAND Circuit can be represented by a binary string of length O((n + s)log(n + s)).
}
{
    We define size$_{n, m}$(s) to be all circuits on n inputs, m outputs, with at most s gates. The goal is to find an encoding E from this function to binary strings.

    What do we need to specify in a NAND circuit?
    \begin{itemize}
        \item how many inputs? n
        \item how many outputs? m
        \item how many gates? $s_0 \le s$
        \item which nodes correspond to output variables (list of indices corresponding to y[i])
        \item links between gates (pairs of nodes whose outputs are inputs to current index node)
    \end{itemize}

    We can store these features as a tuple and encode it in the standard nested PFE.

    \begin{example}
        \begin{center}
            \img{./img/circuit-encoding.png}
        \end{center}
    \end{example}

    How exactly to get valid encoding of list shown above?
    \begin{itemize}
        \item for n, m, and size we encode them with PFE
        \item same for node output numbers (we know there are m of them)
        \item same for pairs (simply read two of them at a time when decoding, we know there will be 2 * $s_0$ integers b/c 2 integer inputs for every gate)
    \end{itemize}

    How many bits are we using?
    \begin{itemize}
        \item recall that the PFE of an integer $a$ takes $\le 2log_2(a)$ bits
        \item $2log_2(n) + 2log_2(m) + 2 log_2(s_0)$ for first 3 integers
        \item $m * 2log_2(n + s_0)$ for m integers in output list
        \item $2s_0 * 2log_2(n + s_0)$ for $2s_0$ integers in pairs
        \item adding these terms together we determine that this is $\le 12(n+s)log_2(n+s)$ as stated in the theorem
    \end{itemize}
}

\hr

\subsubsection*{Corollary 1. Some Functions Require Exponential Size Circuits}

\theoremproof{
    There exists functions $f: \{0, 1\}^n \rightarrow \{0,1\}$ that require circuits of size $\frac{c*2^n}{n}$ for c > 0.
}
{

First some definitions.

\[
    \text{All}_n = \{ f:\{0,1\}^n \rightarrow \{0, 1\} \}
\]
The above function is the class of all functions from n-length binary strings to 0 or 1.

\[
    SIZE_n(s) = \{ \text{All functions with 1 bit output computable by circuits of size} \le s \}
\]

We want to show that $|All_n| > |SIZE_n(\frac{c*2^n}{n})|$.
\begin{itemize}
    \item Counting $All_n$
    \begin{itemize}
        \item we know there are $2^n$ possible inputs
        \item each of these has 2 possible outputs
        \item so we have $2^{2^n}$ possible functions (2 possible outputs over $2^n$ rows)
    \end{itemize}
    \item Counting $SIZE_n(s)$
    \begin{itemize}
        \item idea: count using encodings
        \item \# circuits $\le$ number of binary strings of length $12(n + s)log_2(n + s)$
        \item we know the number of strings of length $\le l$ is $2^0 + 2^1 + 2^2 + 2^3 + ... + 2^l = 2^{l + 1} - 1$ (geometric series)
        \item so the number of circuits $\le 2 * 2^{12(n+s)log_2(n+s)}$
    \end{itemize}
\end{itemize}

To finish we need to compare $|ALL_n|$ to $|SIZE_n(s)|$. We will skip the algebraic manipulation (see lecture notes for that), but the conclusion is that $|ALL_n|$ > $|SIZE_n(s)|$ where $s = \frac{2^n}{24n}$. Therefore $\exists$ functions on n bits that require $\frac{2^n}{24n}$ gates to compute.
}

\hr

\subsubsection*{Corollary 2: Universal Circuits}

We know that we can encode a circuit as a binary string. Let's define a a function to take advantage of this fact.

\begin{definition}    
    EVAL: $\{0, 1\}^{S(n, m, s)} \times \{0,1\}^n \rightarrow \{0,1\}^m$

    \begin{equation}
        \text{EVAL}(C, x) = 
        \begin{cases}
            C(x) & \text{if C is a valid circuit} \\
            0^m & \text{else}
        \end{cases}
    \end{equation}
\end{definition}

\begin{theorem}
    There is a circuit for EVAL$_{n, m, s}$ of size $O(s^2logs)$.
\end{theorem}

\hr

One last major idea: Circuits are efficient.

\begin{theorem}
    Physical Extended Church-Turing Thesis(PECTT)

    If a function can be computed using s physical resources, then it can be computed by a circuit that uses roughly s gates. In other words, circuits are about as efficient as we can get in terms of computation.    
\end{theorem}


\subsubsection*{Summary}
\begin{itemize}
    \item circuits can be implemented on physical devices
    \item every functin can be computed by circuits
    \item some functions require exponential size circuits
    \item universal circuits of size $cs^2logs$ can simulations all size s circuits
\end{itemize}







