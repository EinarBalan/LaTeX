\chapter{Turing Machines}

As we showed in the last chapter with our discussion of Pumping Lemma, DFA's are not able to compute all functions. For example, it is impossible to compute if a string is a palindrome using a DFA. This is due to the limitation of memory and only single pass algorithms. Can we create a model that can computes on arbitrary length inputs and is not subject to these limitations? 

We will discuss Turing Machines, introduced by Alan Turing in 1936. This model of computation is as powerful as it gets. It will give us the ability to move the "head" both directions on input and read and write to a variable amount of memory. Essentially,

\[
    \text{Turing Machines} = \text{DFAs + left/right movement on input + read/write memory}
\]

\subsection*{Anatomy of a Turing Machine}
A turing machine consists of an infinitely long tape, on which the inputs are loaded into the first n spots. It can be thought of as an array. There are a finite number, k, states. The head can move left, right, or stay depending on the current state and the current symbol being read. 

\begin{center}
    \img{./img/turing-machine.png}
\end{center}

In each step of computation, we are in a state i and read the bit at the head of the tape. We can take several actions including
\begin{itemize}
    \item changing the state
    \item write something new at the head 
    \item move the head (left, right, or stay)
\end{itemize}

\begin{definition}
    Turing Machines

    \begin{itemize}
        \item k states
        \item $\Sigma \supseteq \{ 0, 1, \triangleright, \null \varnothing \}$ (there is a finite alphabet)
        \begin{itemize}
            \item $\triangleright$ denotes the start of the tape
            \item $\varnothing$ denotes nothing is at that position in the tape
        \end{itemize}
        \item Transition function $\delta: \{0, 1, ..., k - 1 \} \times \Sigma \times \{ L, R, S, H \}$
        \begin{itemize}
            \item $\delta(\text{state}_i, a) = (\text{state}_j, b, L)$
            \item a is the symbol being read, state$_j$ is the new state to go to, b is the symbol to write at the head, and L is the direction to go in
            \item H stands for halt
        \end{itemize}
    \end{itemize}
\end{definition}

Computation:
\begin{verbatim}
    Start with head at x[0]
    State: "0" (starting state)
    Repeat:
        (new_state, new_symbol, A) = delta(current_state, Tape[Head])
        cur_state = new_state
        Tape[Head] = new_symbol
        if A == L: Head = max(0, Head - 1)
        if A == R: Head += 1
        if A == S: Head = Head
        if A == H: exit()
\end{verbatim}

By convention if a Turing Machine M halts on an input, then the output is the contents of the tape up to and including the head. If M does not halt, M(x) = "$\perp$". We say a function is computed by a TM M if f(x) = M(x) for all x. A language L is recognized by M if $x \in L \implies M(x) = 1$ and $x \notin L \implies M(x) = 0$.

\begin{example}
    
    $ k = 1, \Sigma = \{0, 1, \triangleright, \varnothing \}$
    \begin{gather*}
        \delta_M(0, 0) = (0, 1, R) \\
        \delta_M(0, 1) = (0, 0, R) \\ 
        \delta_M(0, \varnothing) = (0, \varnothing, H) \\
    \end{gather*}

    This Turing Machine simply computes the complement of the input. That is if we load in 1001, we will get 0110 as output. 

\end{example}

\begin{example}
    Now we show that Turing Machines are more powerful than DFA's by showing we can compute a function that DFA's cannot: MAJ.

    \begin{gather*}
        MAJ:\{0, 1\}^* \rightarrow \{0, 1\} \\
        MAJ(x) = 
        \begin{cases}
            1 & \text{if there are at least as many 1's as 0's} \\
            0 & \text{else}
        \end{cases}
    \end{gather*}
    
    The idea here is to try to match every 0 we see to a 1. If we are unable to match a 0, then there are more 0's than 1's and we output 0. 
    
    Pseudocode:
    \begin{verbatim}
        1. Scan to to the right until a 0 is found
        2. If no 0 is found:
            "clean up" the tape and return 1
        3. If a 0 is found:
            Mark the 0 as seen 
            Go to the start of the tape
            Scan the input to find a 1
            If 1 found:
                Mark 1 as seen
                Go to start
            If 1 not found:
                clean up and return 0
    \end{verbatim}
    
    Click \href{http://turingmachinesimulator.com/shared/ftcgvwwbaj}{here} for a visualization.   
\end{example}

\begin{example}
    Another function that DFA's could not compute was palindrome. Recall that palindrome returned 1 if the input string was the same forwards as it was backwards.

    Here the idea is to look at the first symbol in the string, then proceed to the end and look at the last symbol. If they are not the same, we return 0. If they are the same, we mark both symbols as seen and proceed to the first unseen symbol and repeat. 

    Pseudocode:
    \begin{verbatim}
        1. Enter state that remembers the first bit x: GoEndx and mark first bit as seen 
        (overwrite with a)
        2. Go to the end
        3. If the last bit matches x 
            Replace it with nothing and proceed to first unseen bit
            Repeat
        4. If the last bit does not match x
            Clean up the tape and return 0
        5. If there are no bits remaining that have not been seen:
            Clean up the tape and return 1
    \end{verbatim}

    I will omit the precise transition function definitions, but that along with a visualization can be found \href{http://turingmachinesimulator.com/shared/mngibtvnaj}{here}. 
\end{example}

From these two examples, we can see that Turing Machines are more powerful than DFA's as they can compute functions that DFA's cannot. We can take this a step further and say that Turing Machines are essentially as powerful as it gets. They are functionally equivalent to modern day programming languages and can simulate things such as random access.

\begin{theorem}
    
    For every python program P, $\exists$ a TM M such that $\forall$ x P(x) = M(x). In other words, Turing machines are computationally equivalent to Python. If P takes T time to compute, M will take $T^2$ time. 
\end{theorem}

\begin{theorem}
    A function f is computable if there exists a TM M for which f(x) = M(x) for all x. 
\end{theorem}

\vspace{1cm}


\begin{thesisframe}
    \kw{Thesis}
    Church-Turing Thesis
    
    \vspace{.25cm}

    Every function that is computable by physical means is computable by a Turing Machine.
\end{thesisframe}


